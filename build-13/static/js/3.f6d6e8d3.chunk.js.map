{"version":3,"sources":["../../src/Observable.ts","../../src/Subscriber.ts","../../../src/util/root.ts","../../../src/observable/ArrayObservable.ts","../../../src/util/isScheduler.ts","../../src/OuterSubscriber.ts","../../../src/util/subscribeToResult.ts","../../../src/observable/merge.ts","../node_modules/recompose/setDisplayName.js","../../../src/util/isArray.ts","../../../src/util/errorObject.ts","../../../src/symbol/observable.ts","../../../src/scheduler/async.ts","../../../src/observable/ScalarObservable.ts","../../../src/observable/EmptyObservable.ts","../../../src/symbol/iterator.ts","../node_modules/recompose/setStatic.js","../node_modules/recompose/wrapDisplayName.js","../node_modules/symbol-observable/es/index.js","../node_modules/webpack/buildin/global.js","../node_modules/recompose/setObservableConfig.js","../../../src/util/isFunction.ts","../../src/Subscription.ts","../../../src/util/isObject.ts","../../../src/util/tryCatch.ts","../../src/Observer.ts","../../../src/symbol/rxSubscriber.ts","../../../src/util/isArrayLike.ts","../../../src/util/isPromise.ts","../../../src/observable/of.ts","../../../src/observable/from.ts","../../src/Notification.ts","../../../src/operators/mergeAll.ts","../../../src/util/identity.ts","../../../src/operators/switchMap.ts","../node_modules/ramda/src/internal/_isPlaceholder.js","../node_modules/invariant/browser.js","../node_modules/json2mq/index.js","../node_modules/string-convert/camel2hyphen.js","../node_modules/react-progressive-bg-image/lib/index.js","../node_modules/react-progressive-bg-image/lib/ProgressiveImage.js","../node_modules/recompose/compose.js","../node_modules/recompose/defaultProps.js","../node_modules/recompose/getDisplayName.js","../node_modules/recompose/setPropTypes.js","../node_modules/recompose/mapPropsStream.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/recompose/componentFromStream.js","../node_modules/change-emitter/lib/index.js","../../../src/util/toSubscriber.ts","../../../src/util/UnsubscriptionError.ts","../../../src/util/pipe.ts","../../../src/util/noop.ts","../../../src/scheduler/AsyncAction.ts","../../../src/scheduler/Action.ts","../../../src/scheduler/AsyncScheduler.ts","../../src/Scheduler.ts","../../../../src/add/operator/combineLatest.ts","../../../src/operator/combineLatest.ts","../../../src/operators/combineLatest.ts","../../src/InnerSubscriber.ts","../../../../src/add/operator/startWith.ts","../../../src/operator/startWith.ts","../../../src/operators/startWith.ts","../../../src/observable/concat.ts","../../../src/observable/FromObservable.ts","../../../src/observable/PromiseObservable.ts","../../../src/observable/IteratorObservable.ts","../../../src/observable/ArrayLikeObservable.ts","../../../src/operators/observeOn.ts","../../../src/operators/concatAll.ts","../../../src/operators/mergeMap.ts","../../../../src/add/operator/switchMapTo.ts","../../../src/operator/switchMapTo.ts","../../../src/operators/switchMapTo.ts","../../../../src/add/operator/delay.ts","../../../src/operator/delay.ts","../../../src/operators/delay.ts","../../../src/util/isDate.ts","../../../../src/add/operator/merge.ts","../../../src/operator/merge.ts","../../../src/operators/merge.ts","../../../../src/add/operator/filter.ts","../../../src/operator/filter.ts","../../../src/operators/filter.ts","../../../../src/add/operator/switchMap.ts","../../../src/operator/switchMap.ts","../../../../src/add/operator/mapTo.ts","../../../src/operator/mapTo.ts","../../../src/operators/mapTo.ts","../../../../src/add/operator/switch.ts","../../../src/operator/switch.ts","../../../src/operators/switchAll.ts","../../../../src/add/operator/map.ts","../../../src/operator/map.ts","../../../src/operators/map.ts","../../../../src/add/operator/distinctUntilChanged.ts","../../../src/operator/distinctUntilChanged.ts","../../../src/operators/distinctUntilChanged.ts","../../../../src/add/observable/from.ts","../../../../src/add/observable/of.ts","../../../../src/add/observable/merge.ts","../node_modules/react-progressive-bg-image/lib/Img.js","../node_modules/ramda/src/omit.js","../node_modules/ramda/src/internal/_curry2.js","../node_modules/ramda/src/internal/_curry1.js","../node_modules/react-progressive-bg-image/lib/loadImage.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/react-media/esm/react-media.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js"],"names":["subscribe","_isScalar","this","_subscribe","lift","operator","observable","Observable","source","observerOrNext","error","complete","sink","toSubscriber","call","add","syncErrorThrowable","_trySubscribe","syncErrorThrown","syncErrorValue","err","forEach","next","PromiseCtor","root","Rx","config","Promise","Error","resolve","reject","subscription","value","unsubscribe","subscriber","pipe","operations","length","pipeFromArray","toPromise","x","create","destinationOrNext","isStopped","arguments","destination","empty","isTrustedSubscriber","trustedSubscriber","rxSubscriber","SafeSubscriber","Subscriber","_next","_error","_complete","closed","_unsubscribeAndRecycle","_parent","_parents","Subscription","_parentSubscriber","context","isFunction","Object","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","fn","parent","_unsubscribe","obj","__window","window","__self","self","WorkerGlobalScope","_root","global","array","scheduler","ArrayObservable","of","isScheduler","pop","len","ScalarObservable","EmptyObservable","dispatch","state","index","count","schedule","i","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","OuterSubscriber","subscribeToResult","outerSubscriber","result","InnerSubscriber","isArrayLike","isPromise","then","setTimeout","iterator","item","done","obs","TypeError","msg","isObject","merge","concurrent","Number","POSITIVE_INFINITY","last","observables","mergeAll","exports","__esModule","_setStatic","require","_setStatic2","default","displayName","isArray","Array","errorObject","e","$$observable","Symbol","getSymbolObservable","async","AsyncScheduler","AsyncAction","arg","Set","Map","keys","getOwnPropertyNames","prototype","key","symbolIteratorPonyfill","$$iterator","BaseComponent","_getDisplayName","_getDisplayName2","hocName","module","ponyfill","g","Function","_config","fromESObservable","toESObservable","stream","c","_subscriptions","errors","hasErrors","remove","tryCatch","UnsubscriptionError","flattenUnsubscriptionErrors","sub","concat","push","teardown","EMPTY","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","reduce","errs","tryCatchTarget","tryCatcher","apply","for","$$rxSubscriber","from","FromObservable","kind","hasValue","observe","observer","do","accept","nextOrObserver","toObservable","throw","createNext","Notification","undefinedValueNotification","createError","undefined","createComplete","completeNotification","mergeMap","identity","switchMap","project","resultSelector","SwitchMapOperator","SwitchMapSubscriber","_innerSub","innerSubscription","_tryNotifyNext","a","condition","format","b","d","f","args","argIndex","replace","name","framesToPop","camel2hyphen","obj2mq","mq","features","feature","test","isDimension","query","q","str","match","toLowerCase","defineProperty","_ProgressiveImage","_ProgressiveImage2","DELAY","ownerPropsToChildProps","_propTypes2","_interopRequireDefault","_compose2","_setDisplayName2","_defaultProps2","_setPropTypes2","_mapPropsStream2","_Observable","_async","_Img2","_loadImage2","propStream","load","t","props$","placeholder$","map","placeholder","imagePromise$","src","startWith","isCached","src$","filter","isCached$","distinctUntilChanged","isLoaded$","mapTo","_ref","delay","switch","image$","combineLatest","props","image","isLoaded","assign","string","isRequired","opacity","number","blur","scale","component","oneOfType","func","transition","_len","funcs","_key","_react","factory","createFactory","DefaultProps","ownerProps","defaultProps","Component","propTypes","mapPropsStreamWithConfig","_symbolObservable2","_componentFromStream","_setObservableConfig","componentFromStream","componentFromStreamWithConfig","transform","childProps","originalModule","webpackPolyfill","children","enumerable","get","l","symbolObservablePonyfill","_changeEmitter","_symbolObservable","_classCallCheck","instance","Constructor","_possibleConstructorReturn","ReferenceError","propsToVdom","_Component","ComponentFromStream","_config$fromESObserva","_temp","_this","vdom","propsEmitter","createChangeEmitter","listen","vdom$","subClass","superClass","constructor","writable","configurable","setPrototypeOf","__proto__","_inherits","componentWillMount","_this2","setState","emit","componentWillReceiveProps","nextProps","shouldComponentUpdate","nextState","componentWillUnmount","render","currentListeners","nextListeners","ensureCanMutateNextListeners","slice","listener","isSubscribed","listeners","join","stack","message","fns","input","prev","noop","work","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","actions","Action","active","scheduled","action","shift","Scheduler","SchedulerAction","now","Date","none","CombineLatestOperator","CombineLatestSubscriber","values","toRespond","unused","oldVal","_tryProject","concatAll","ish","PromiseObservable","IteratorObservable","ArrayLikeObservable","ObserveOnSubscriber","promise","dispatchNext","dispatchError","StringIterator","ArrayIterator","getIterator","hasError","return","idx","charAt","arr","o","isNaN","isFinite","valueAsNumber","sign","Math","floor","abs","maxSafeInteger","toLength","pow","arrayLike","observeOn","ObserveOnOperator","notification","scheduleMessage","ObserveOnMessage","MergeMapOperator","MergeMapSubscriber","hasCompleted","buffer","_tryNext","_notifyResultSelector","switchMapTo","innerObservable","SwitchMapToOperator","SwitchMapToSubscriber","inner","tryResultSelector","delayFor","isDate","DelayOperator","DelaySubscriber","queue","time","max","_schedule","scheduleNotification","DelayMessage","predicate","thisArg","FilterOperator","FilterSubscriber","MapToOperator","MapToSubscriber","_switch","switchAll","MapOperator","MapSubscriber","compare","keySelector","DistinctUntilChangedOperator","DistinctUntilChangedSubscriber","hasKey","y","Boolean","strings","raw","_templateObject","freeze","defineProperties","React","newObj","hasOwnProperty","_interopRequireWildcard","_omit2","_styledComponents2","_objectWithoutProperties","target","omitProps","otherProps","createElement","node","StyledImg","Img","_ref2","style","backgroundImage","bool","className","object","omit","_curry2","names","prop","_curry1","_isPlaceholder","f2","_b","_a","f1","Image","width","height","onload","onerror","_extends","_assertThisInitialized","_defineProperty","MediaQueryListener","targetWindow","nativeMediaQueryList","matchMedia","cancellableListener","matches","addListener","cancel","removeListener","queryType","PropTypes","arrayOf","Media","_React$Component","queryObject","queryNames","__DEFAULT__","unwrapSingleQuery","queries","acc","_extends2","mqListener","newMatches","getMatches","onChange","invariant","defaultMatches","_extends3","initialize","_proto","qs","json2mq","updateMatches","componentDidMount","_this$props","isAnyMatches","some","Children","only","type","cloneElement","objectOf"],"mappings":"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","file":"static/js/3.f6d6e8d3.chunk.js","sourcesContent":["import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { OperatorFunction } from './interfaces';\nimport { pipeFromArray } from './util/pipe';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  /** @deprecated internal use only */ public source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R>\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(PromiseCtor?: PromiseConstructorLike) {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): To resolve an issue where Node users may have multiple\n          // copies of rxjs in their node_modules directory.\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated internal use only */ _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated internal use only */ _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n","declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nexport function isScheduler(value: any): value is Scheduler {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { ArrayObservable } from './ArrayObservable';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(v1: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: IScheduler): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | IScheduler | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | IScheduler | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: IScheduler = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <IScheduler>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll(concurrent)(new ArrayObservable(<any>observables, scheduler)) as Observable<R>;\n}\n","'use strict';\n\nexports.__esModule = true;\n\nvar _setStatic = require('./setStatic');\n\nvar _setStatic2 = _interopRequireDefault(_setStatic);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar setDisplayName = function setDisplayName(displayName) {\n  return (0, _setStatic2.default)('displayName', displayName);\n};\n\nexports.default = setDisplayName;","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ScalarObservable<T> extends Observable<T> {\n  static create<T>(value: T, scheduler?: IScheduler): ScalarObservable<T> {\n    return new ScalarObservable(value, scheduler);\n  }\n\n  static dispatch(state: any): void {\n    const { done, value, subscriber } = state;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    (<any> this).schedule(state);\n  }\n\n  _isScalar: boolean = true;\n\n  constructor(public value: T, private scheduler?: IScheduler) {\n    super();\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const value = this.value;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false, value, subscriber\n      });\n    } else {\n      subscriber.next(value);\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\nexport interface DispatchArg<T> {\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class EmptyObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits a complete notification.\n   *\n   * <span class=\"informal\">Just emits 'complete', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/empty.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the complete notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then complete.</caption>\n   * var result = Rx.Observable.empty().startWith(7);\n   * result.subscribe(x => console.log(x));\n   *\n   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n   * );\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following to the console:\n   * // x is equal to the count on the interval eg(0,1,2,3,...)\n   * // x will occur every 1000ms\n   * // if x % 2 is equal to 1 print abc\n   * // if x % 2 is not equal to 1 nothing will be output\n   *\n   * @see {@link create}\n   * @see {@link never}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the complete notification.\n   * @return {Observable} An \"empty\" Observable: emits only the complete\n   * notification.\n   * @static true\n   * @name empty\n   * @owner Observable\n   */\n  static create<T>(scheduler?: IScheduler): Observable<T> {\n    return new EmptyObservable<T>(scheduler);\n  }\n\n  static dispatch<T>(arg: DispatchArg<T>) {\n    const { subscriber } = arg;\n    subscriber.complete();\n  }\n\n  constructor(private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber });\n    } else {\n      subscriber.complete();\n    }\n  }\n}\n","import { root } from '../util/root';\n\nexport function symbolIteratorPonyfill(root: any) {\n  const Symbol: any = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    const { Set } = root;\n    if (Set && typeof new Set()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n    const { Map } = root;\n    // required for compatability with es6-shim\n    if (Map) {\n      let keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        let key = keys[i];\n        // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n    return '@@iterator';\n  }\n}\n\nexport const iterator = symbolIteratorPonyfill(root);\n\n/**\n * @deprecated use iterator instead\n */\nexport const $$iterator = iterator;\n","\"use strict\";\n\nexports.__esModule = true;\nvar setStatic = function setStatic(key, value) {\n  return function (BaseComponent) {\n    /* eslint-disable no-param-reassign */\n    BaseComponent[key] = value;\n    /* eslint-enable no-param-reassign */\n    return BaseComponent;\n  };\n};\n\nexports.default = setStatic;","'use strict';\n\nexports.__esModule = true;\n\nvar _getDisplayName = require('./getDisplayName');\n\nvar _getDisplayName2 = _interopRequireDefault(_getDisplayName);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar wrapDisplayName = function wrapDisplayName(BaseComponent, hocName) {\n  return hocName + '(' + (0, _getDisplayName2.default)(BaseComponent) + ')';\n};\n\nexports.default = wrapDisplayName;","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict';\n\nexports.__esModule = true;\nvar _config = {\n  fromESObservable: null,\n  toESObservable: null\n};\n\nvar configureObservable = function configureObservable(c) {\n  _config = c;\n};\n\nvar config = exports.config = {\n  fromESObservable: function fromESObservable(observable) {\n    return typeof _config.fromESObservable === 'function' ? _config.fromESObservable(observable) : observable;\n  },\n  toESObservable: function toESObservable(stream) {\n    return typeof _config.toESObservable === 'function' ? _config.toESObservable(stream) : stream;\n  }\n};\n\nexports.default = configureObservable;","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number');","export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import {  ArrayObservable  } from './ArrayObservable';\n\nexport const of = ArrayObservable.of;","import {  FromObservable  } from './FromObservable';\n\nexport const from = FromObservable.create;","import { PartialObserver } from './Observer';\nimport { Observable } from './Observable';\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: string, public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return Observable.of(this.value);\n      case 'E':\n        return Observable.throw(this.error);\n      case 'C':\n        return Observable.empty<T>();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","\nimport { ObservableInput } from '../Observable';\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport function mergeAll<T>(concurrent: number = Number.POSITIVE_INFINITY): MonoTypeOperatorFunction<T> {\n  return mergeMap(identity as (value: T, index: number) => ObservableInput<{}>, null, concurrent);\n}","export function identity<T>(x: T): T {\n  return x;\n}\n","import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\nexport function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, I | R> {\n  return function switchMapOperatorFunction(source: Observable<T>): Observable<I | R> {\n    return source.lift(new SwitchMapOperator(project, resultSelector));\n  };\n}\n\nclass SwitchMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<I>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(result: ObservableInput<I>, value: T, index: number) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, result, value, index));\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _tryNotifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): void {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}\nmodule.exports = _isPlaceholder;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var camel2hyphen = require('string-convert/camel2hyphen');\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;","var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ProgressiveImage = require('./ProgressiveImage');\n\nvar _ProgressiveImage2 = _interopRequireDefault(_ProgressiveImage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _ProgressiveImage2.default;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DELAY = undefined;\nexports.ownerPropsToChildProps = ownerPropsToChildProps;\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _compose = require('recompose/compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nvar _setDisplayName = require('recompose/setDisplayName');\n\nvar _setDisplayName2 = _interopRequireDefault(_setDisplayName);\n\nvar _defaultProps = require('recompose/defaultProps');\n\nvar _defaultProps2 = _interopRequireDefault(_defaultProps);\n\nvar _setPropTypes = require('recompose/setPropTypes');\n\nvar _setPropTypes2 = _interopRequireDefault(_setPropTypes);\n\nvar _mapPropsStream = require('recompose/mapPropsStream');\n\nvar _mapPropsStream2 = _interopRequireDefault(_mapPropsStream);\n\nvar _Observable = require('rxjs/Observable');\n\nvar _async = require('rxjs/scheduler/async');\n\nrequire('rxjs/add/operator/combineLatest');\n\nrequire('rxjs/add/operator/startWith');\n\nrequire('rxjs/add/operator/switchMapTo');\n\nrequire('rxjs/add/operator/delay');\n\nrequire('rxjs/add/operator/merge');\n\nrequire('rxjs/add/operator/filter');\n\nrequire('rxjs/add/operator/switchMap');\n\nrequire('rxjs/add/operator/mapTo');\n\nrequire('rxjs/add/operator/switch');\n\nrequire('rxjs/add/operator/map');\n\nrequire('rxjs/add/operator/distinctUntilChanged');\n\nrequire('rxjs/add/observable/from');\n\nrequire('rxjs/add/observable/of');\n\nrequire('rxjs/add/observable/merge');\n\nvar _Img = require('./Img');\n\nvar _Img2 = _interopRequireDefault(_Img);\n\nvar _loadImage = require('./loadImage');\n\nvar _loadImage2 = _interopRequireDefault(_loadImage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DELAY = exports.DELAY = 200;\n\nfunction ownerPropsToChildProps(propStream) {\n  var load = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _loadImage2.default;\n  var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DELAY;\n  var scheduler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _async.async;\n\n  var props$ = _Observable.Observable.from(propStream);\n  var placeholder$ = props$.map(function (e) {\n    return e.placeholder;\n  });\n  var imagePromise$ = props$.map(function (e) {\n    return e.src;\n  }).switchMap(load).startWith({ src: '', isCached: false });\n\n  var src$ = imagePromise$.map(function (e) {\n    return e.src;\n  }).filter(function (src) {\n    return !!src;\n  });\n  var isCached$ = imagePromise$.map(function (e) {\n    return e.isCached;\n  }).distinctUntilChanged();\n\n  var isLoaded$ = _Observable.Observable.merge(placeholder$.mapTo(_Observable.Observable.of(false)), imagePromise$.map(function (_ref) {\n    var isCached = _ref.isCached;\n    return _Observable.Observable.of(true).delay(isCached ? 0 : t, scheduler);\n  })).switch().startWith(false).distinctUntilChanged();\n\n  var image$ = placeholder$.merge(src$).distinctUntilChanged();\n\n  return props$.combineLatest(image$, isCached$, isLoaded$, function (props, image, isCached, isLoaded) {\n    return Object.assign({}, props, {\n      image: image,\n      isCached: isCached,\n      isLoaded: isLoaded\n    });\n  });\n}\n\nexports.default = (0, _compose2.default)((0, _setDisplayName2.default)('ProgressiveImage'), (0, _setPropTypes2.default)({\n  src: _propTypes2.default.string.isRequired,\n  placeholder: _propTypes2.default.string.isRequired,\n  opacity: _propTypes2.default.number,\n  blur: _propTypes2.default.number,\n  scale: _propTypes2.default.number,\n  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func])\n}), (0, _defaultProps2.default)({\n  opacity: 0.5,\n  blur: 20,\n  scale: 1,\n  transition: 'opacity 0.3s linear',\n  component: 'div'\n}), (0, _mapPropsStream2.default)(ownerPropsToChildProps))(_Img2.default);","\"use strict\";\n\nexports.__esModule = true;\nexports.default = compose;\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}","'use strict';\n\nexports.__esModule = true;\n\nvar _react = require('react');\n\nvar _setDisplayName = require('./setDisplayName');\n\nvar _setDisplayName2 = _interopRequireDefault(_setDisplayName);\n\nvar _wrapDisplayName = require('./wrapDisplayName');\n\nvar _wrapDisplayName2 = _interopRequireDefault(_wrapDisplayName);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar defaultProps = function defaultProps(props) {\n  return function (BaseComponent) {\n    var factory = (0, _react.createFactory)(BaseComponent);\n    var DefaultProps = function DefaultProps(ownerProps) {\n      return factory(ownerProps);\n    };\n    DefaultProps.defaultProps = props;\n    if (process.env.NODE_ENV !== 'production') {\n      return (0, _setDisplayName2.default)((0, _wrapDisplayName2.default)(BaseComponent, 'defaultProps'))(DefaultProps);\n    }\n    return DefaultProps;\n  };\n};\n\nexports.default = defaultProps;","'use strict';\n\nexports.__esModule = true;\nvar getDisplayName = function getDisplayName(Component) {\n  if (typeof Component === 'string') {\n    return Component;\n  }\n\n  if (!Component) {\n    return undefined;\n  }\n\n  return Component.displayName || Component.name || 'Component';\n};\n\nexports.default = getDisplayName;","'use strict';\n\nexports.__esModule = true;\n\nvar _setStatic = require('./setStatic');\n\nvar _setStatic2 = _interopRequireDefault(_setStatic);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar setPropTypes = function setPropTypes(propTypes) {\n  return (0, _setStatic2.default)('propTypes', propTypes);\n};\n\nexports.default = setPropTypes;","'use strict';\n\nexports.__esModule = true;\nexports.mapPropsStreamWithConfig = undefined;\n\nvar _react = require('react');\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nvar _componentFromStream = require('./componentFromStream');\n\nvar _setDisplayName = require('./setDisplayName');\n\nvar _setDisplayName2 = _interopRequireDefault(_setDisplayName);\n\nvar _wrapDisplayName = require('./wrapDisplayName');\n\nvar _wrapDisplayName2 = _interopRequireDefault(_wrapDisplayName);\n\nvar _setObservableConfig = require('./setObservableConfig');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar identity = function identity(t) {\n  return t;\n};\n\nvar mapPropsStreamWithConfig = exports.mapPropsStreamWithConfig = function mapPropsStreamWithConfig(config) {\n  var componentFromStream = (0, _componentFromStream.componentFromStreamWithConfig)({\n    fromESObservable: identity,\n    toESObservable: identity\n  });\n  return function (transform) {\n    return function (BaseComponent) {\n      var factory = (0, _react.createFactory)(BaseComponent);\n      var fromESObservable = config.fromESObservable,\n          toESObservable = config.toESObservable;\n\n      return componentFromStream(function (props$) {\n        var _ref;\n\n        return _ref = {\n          subscribe: function subscribe(observer) {\n            var subscription = toESObservable(transform(fromESObservable(props$))).subscribe({\n              next: function next(childProps) {\n                return observer.next(factory(childProps));\n              }\n            });\n            return {\n              unsubscribe: function unsubscribe() {\n                return subscription.unsubscribe();\n              }\n            };\n          }\n        }, _ref[_symbolObservable2.default] = function () {\n          return this;\n        }, _ref;\n      });\n    };\n  };\n};\n\nvar mapPropsStream = function mapPropsStream(transform) {\n  var hoc = mapPropsStreamWithConfig(_setObservableConfig.config)(transform);\n\n  if (process.env.NODE_ENV !== 'production') {\n    return function (BaseComponent) {\n      return (0, _setDisplayName2.default)((0, _wrapDisplayName2.default)(BaseComponent, 'mapPropsStream'))(hoc(BaseComponent));\n    };\n  }\n  return hoc;\n};\n\nexports.default = mapPropsStream;","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","'use strict';\n\nexports.__esModule = true;\nexports.componentFromStreamWithConfig = undefined;\n\nvar _react = require('react');\n\nvar _changeEmitter = require('change-emitter');\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nvar _setObservableConfig = require('./setObservableConfig');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar componentFromStreamWithConfig = exports.componentFromStreamWithConfig = function componentFromStreamWithConfig(config) {\n  return function (propsToVdom) {\n    return function (_Component) {\n      _inherits(ComponentFromStream, _Component);\n\n      function ComponentFromStream() {\n        var _config$fromESObserva;\n\n        var _temp, _this, _ret;\n\n        _classCallCheck(this, ComponentFromStream);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = { vdom: null }, _this.propsEmitter = (0, _changeEmitter.createChangeEmitter)(), _this.props$ = config.fromESObservable((_config$fromESObserva = {\n          subscribe: function subscribe(observer) {\n            var unsubscribe = _this.propsEmitter.listen(function (props) {\n              if (props) {\n                observer.next(props);\n              } else {\n                observer.complete();\n              }\n            });\n            return { unsubscribe: unsubscribe };\n          }\n        }, _config$fromESObserva[_symbolObservable2.default] = function () {\n          return this;\n        }, _config$fromESObserva)), _this.vdom$ = config.toESObservable(propsToVdom(_this.props$)), _temp), _possibleConstructorReturn(_this, _ret);\n      }\n\n      // Stream of props\n\n\n      // Stream of vdom\n\n\n      ComponentFromStream.prototype.componentWillMount = function componentWillMount() {\n        var _this2 = this;\n\n        // Subscribe to child prop changes so we know when to re-render\n        this.subscription = this.vdom$.subscribe({\n          next: function next(vdom) {\n            _this2.setState({ vdom: vdom });\n          }\n        });\n        this.propsEmitter.emit(this.props);\n      };\n\n      ComponentFromStream.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n        // Receive new props from the owner\n        this.propsEmitter.emit(nextProps);\n      };\n\n      ComponentFromStream.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n        return nextState.vdom !== this.state.vdom;\n      };\n\n      ComponentFromStream.prototype.componentWillUnmount = function componentWillUnmount() {\n        // Call without arguments to complete stream\n        this.propsEmitter.emit();\n\n        // Clean-up subscription before un-mounting\n        this.subscription.unsubscribe();\n      };\n\n      ComponentFromStream.prototype.render = function render() {\n        return this.state.vdom;\n      };\n\n      return ComponentFromStream;\n    }(_react.Component);\n  };\n};\n\nvar componentFromStream = function componentFromStream(propsToVdom) {\n  return componentFromStreamWithConfig(_setObservableConfig.config)(propsToVdom);\n};\n\nexports.default = componentFromStream;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createChangeEmitter = exports.createChangeEmitter = function createChangeEmitter() {\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  function listen(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function () {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  function emit() {\n    currentListeners = nextListeners;\n    var listeners = currentListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].apply(listeners, arguments);\n    }\n  }\n\n  return {\n    listen: listen,\n    emit: emit\n  };\n};","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input);\n  };\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { root } from '../util/root';\nimport { Action } from './Action';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n  protected work: (this: this, state?: T) => void;\n\n  constructor(protected scheduler: AsyncScheduler,\n              work: (this: AsyncAction<T>, state?: T) => void) {\n    super(scheduler, work);\n    this.work = work;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return root.clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\n\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: Action<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\n\nexport interface IScheduler {\n  now(): number;\n  schedule<T>(work: (this: Action<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nexport class Scheduler implements IScheduler {\n\n  public static now: () => number = Date.now ? Date.now : () => +new Date();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: Action<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","\nimport { Observable } from '../../Observable';\nimport { combineLatest } from '../../operator/combineLatest';\n\nObservable.prototype.combineLatest = combineLatest;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    combineLatest: typeof combineLatest;\n  }\n}","import { Observable, ObservableInput } from '../Observable';\nimport { combineLatest as higherOrder } from '../operators/combineLatest';\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, R>(this: Observable<T>, project: (v1: T) => R): Observable<R>;\nexport function combineLatest<T, T2, R>(this: Observable<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;\nexport function combineLatest<T, T2, T3, R>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;\nexport function combineLatest<T, T2, T3, T4, R>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R> ;\nexport function combineLatest<T, T2>(this: Observable<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function combineLatest<T, T2, T3>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]> ;\nexport function combineLatest<T, R>(this: Observable<T>, ...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport function combineLatest<T, R>(this: Observable<T>, array: ObservableInput<T>[]): Observable<Array<T>>;\nexport function combineLatest<T, TOther, R>(this: Observable<T>, array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nexport function combineLatest<T, R>(this: Observable<T>, ...observables: Array<ObservableInput<any> |\n                                                       Array<ObservableInput<any>> |\n                                                       ((...values: Array<any>) => R)>): Observable<R> {\n  return higherOrder(...observables)(this);\n}","import { Observable, ObservableInput } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(new ArrayObservable([source, ...observables]), new CombineLatestOperator(project));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private project?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private project?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(none);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryProject(values: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index: number = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, private outerValue: T, private outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","\nimport { Observable } from '../../Observable';\nimport { startWith } from '../../operator/startWith';\n\nObservable.prototype.startWith = startWith;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    startWith: typeof startWith;\n  }\n}","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { startWith as higherOrder } from '../operators/startWith';\n\n/* tslint:disable:max-line-length */\nexport function startWith<T>(this: Observable<T>, v1: T, scheduler?: IScheduler): Observable<T>;\nexport function startWith<T>(this: Observable<T>, v1: T, v2: T, scheduler?: IScheduler): Observable<T>;\nexport function startWith<T>(this: Observable<T>, v1: T, v2: T, v3: T, scheduler?: IScheduler): Observable<T>;\nexport function startWith<T>(this: Observable<T>, v1: T, v2: T, v3: T, v4: T, scheduler?: IScheduler): Observable<T>;\nexport function startWith<T>(this: Observable<T>, v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: IScheduler): Observable<T>;\nexport function startWith<T>(this: Observable<T>, v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: IScheduler): Observable<T>;\nexport function startWith<T>(this: Observable<T>, ...array: Array<T | IScheduler>): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nexport function startWith<T>(this: Observable<T>, ...array: Array<T | IScheduler>): Observable<T> {\n  return higherOrder(...array)(this);\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { ScalarObservable } from '../observable/ScalarObservable';\nimport { EmptyObservable } from '../observable/EmptyObservable';\nimport { concat as concatStatic } from '../observable/concat';\nimport { isScheduler } from '../util/isScheduler';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function startWith<T>(v1: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, v4: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(...array: Array<T | IScheduler>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nexport function startWith<T>(...array: Array<T | IScheduler>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len === 1) {\n      return concatStatic(new ScalarObservable<T>(<T>array[0], scheduler), source);\n    } else if (len > 1) {\n      return concatStatic(new ArrayObservable<T>(<T[]>array, scheduler), source);\n    } else {\n      return concatStatic(new EmptyObservable<T>(scheduler), source);\n    }\n  };\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { isScheduler } from '../util/isScheduler';\nimport { of } from './of';\nimport { from } from './from';\nimport { concatAll } from '../operators/concatAll';\n\n/* tslint:disable:max-line-length */\nexport function concat<T>(v1: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\nexport function concat<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: IScheduler): Observable<T | T2>;\nexport function concat<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function concat<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function concat<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function concat<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function concat<T>(...observables: (ObservableInput<T> | IScheduler)[]): Observable<T>;\nexport function concat<T, R>(...observables: (ObservableInput<any> | IScheduler)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nexport function concat<T, R>(...observables: Array<ObservableInput<any> | IScheduler>): Observable<R> {\n  if (observables.length === 1 || (observables.length === 2 && isScheduler(observables[1]))) {\n    return from(<any>observables[0]);\n  }\n  return concatAll()(of(...observables)) as Observable<R>;\n}\n","import { isArray } from '../util/isArray';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { PromiseObservable } from './PromiseObservable';\nimport { IteratorObservable } from'./IteratorObservable';\nimport { ArrayObservable } from './ArrayObservable';\nimport { ArrayLikeObservable } from './ArrayLikeObservable';\n\nimport { IScheduler } from '../Scheduler';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObserveOnSubscriber } from '../operators/observeOn';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromObservable<T> extends Observable<T> {\n  constructor(private ish: ObservableInput<T>, private scheduler?: IScheduler) {\n    super(null);\n  }\n\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\n  static create<T, R>(ish: ArrayLike<T>, scheduler?: IScheduler): Observable<R>;\n\n  /**\n   * Creates an Observable from an Array, an array-like object, a Promise, an\n   * iterable object, or an Observable-like object.\n   *\n   * <span class=\"informal\">Converts almost anything to an Observable.</span>\n   *\n   * <img src=\"./img/from.png\" width=\"100%\">\n   *\n   * Convert various other objects and data types into Observables. `from`\n   * converts a Promise or an array-like or an\n   * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n   * object into an Observable that emits the items in that promise or array or\n   * iterable. A String, in this context, is treated as an array of characters.\n   * Observable-like objects (contains a function named with the ES2015 Symbol\n   * for Observable) can also be converted through this operator.\n   *\n   * @example <caption>Converts an array to an Observable</caption>\n   * var array = [10, 20, 30];\n   * var result = Rx.Observable.from(array);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 10 20 30\n   *\n   * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n   * function* generateDoubles(seed) {\n   *   var i = seed;\n   *   while (true) {\n   *     yield i;\n   *     i = 2 * i; // double it\n   *   }\n   * }\n   *\n   * var iterator = generateDoubles(3);\n   * var result = Rx.Observable.from(iterator).take(10);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 3 6 12 24 48 96 192 384 768 1536\n   *\n   * @see {@link create}\n   * @see {@link fromEvent}\n   * @see {@link fromEventPattern}\n   * @see {@link fromPromise}\n   *\n   * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n   * Observable-like, an Array, an iterable or an array-like object to be\n   * converted.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * emissions of values.\n   * @return {Observable<T>} The Observable whose values are originally from the\n   * input object that was converted.\n   * @static true\n   * @name from\n   * @owner Observable\n   */\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T> {\n    if (ish != null) {\n      if (typeof ish[Symbol_observable] === 'function') {\n        if (ish instanceof Observable && !scheduler) {\n          return ish;\n        }\n        return new FromObservable<T>(ish, scheduler);\n      } else if (isArray(ish)) {\n        return new ArrayObservable<T>(ish, scheduler);\n      } else if (isPromise<T>(ish)) {\n        return new PromiseObservable<T>(ish, scheduler);\n      } else if (typeof ish[Symbol_iterator] === 'function' || typeof ish === 'string') {\n        return new IteratorObservable<T>(ish, scheduler);\n      } else if (isArrayLike(ish)) {\n        return new ArrayLikeObservable(ish, scheduler);\n      }\n    }\n\n    throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>) {\n    const ish = this.ish;\n    const scheduler = this.scheduler;\n    if (scheduler == null) {\n      return ish[Symbol_observable]().subscribe(subscriber);\n    } else {\n      return ish[Symbol_observable]().subscribe(new ObserveOnSubscriber(subscriber, scheduler, 0));\n    }\n  }\n}\n","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class IteratorObservable<T> extends Observable<T> {\n  private iterator: any;\n\n  static create<T>(iterator: any, scheduler?: IScheduler): IteratorObservable<T> {\n    return new IteratorObservable(iterator, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { index, hasError, iterator, subscriber } = state;\n\n    if (hasError) {\n      subscriber.error(state.error);\n      return;\n    }\n\n    let result = iterator.next();\n    if (result.done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(result.value);\n    state.index = index + 1;\n\n    if (subscriber.closed) {\n      if (typeof iterator.return === 'function') {\n        iterator.return();\n      }\n      return;\n    }\n\n    (<any> this).schedule(state);\n  }\n\n  constructor(iterator: any, private scheduler?: IScheduler) {\n    super();\n\n    if (iterator == null) {\n      throw new Error('iterator cannot be null.');\n    }\n\n    this.iterator = getIterator(iterator);\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    let index = 0;\n    const { iterator, scheduler } = this;\n\n    if (scheduler) {\n      return scheduler.schedule(IteratorObservable.dispatch, 0, {\n        index, iterator, subscriber\n      });\n    } else {\n      do {\n        let result = iterator.next();\n        if (result.done) {\n          subscriber.complete();\n          break;\n        } else {\n          subscriber.next(result.value);\n        }\n        if (subscriber.closed) {\n          if (typeof iterator.return === 'function') {\n            iterator.return();\n          }\n          break;\n        }\n      } while (true);\n    }\n  }\n}\n\nclass StringIterator {\n  constructor(private str: string,\n              private idx: number = 0,\n              private len: number = str.length) {\n  }\n  [Symbol_iterator]() { return (this); }\n  next() {\n    return this.idx < this.len ? {\n        done: false,\n        value: this.str.charAt(this.idx++)\n    } : {\n        done: true,\n        value: undefined\n    };\n  }\n}\n\nclass ArrayIterator {\n  constructor(private arr: Array<any>,\n              private idx: number = 0,\n              private len: number = toLength(arr)) {\n  }\n  [Symbol_iterator]() { return this; }\n  next() {\n    return this.idx < this.len ? {\n        done: false,\n        value: this.arr[this.idx++]\n    } : {\n        done: true,\n        value: undefined\n    };\n  }\n}\n\nfunction getIterator(obj: any) {\n  const i = obj[Symbol_iterator];\n  if (!i && typeof obj === 'string') {\n    return new StringIterator(obj);\n  }\n  if (!i && obj.length !== undefined) {\n    return new ArrayIterator(obj);\n  }\n  if (!i) {\n    throw new TypeError('object is not iterable');\n  }\n  return obj[Symbol_iterator]();\n}\n\nconst maxSafeInteger = Math.pow(2, 53) - 1;\n\nfunction toLength(o: any) {\n  let len = +o.length;\n  if (isNaN(len)) {\n      return 0;\n  }\n  if (len === 0 || !numberIsFinite(len)) {\n      return len;\n  }\n  len = sign(len) * Math.floor(Math.abs(len));\n  if (len <= 0) {\n      return 0;\n  }\n  if (len > maxSafeInteger) {\n      return maxSafeInteger;\n  }\n  return len;\n}\n\nfunction numberIsFinite(value: any) {\n  return typeof value === 'number' && root.isFinite(value);\n}\n\nfunction sign(value: any) {\n  let valueAsNumber = +value;\n  if (valueAsNumber === 0) {\n    return valueAsNumber;\n  }\n  if (isNaN(valueAsNumber)) {\n    return valueAsNumber;\n  }\n  return valueAsNumber < 0 ? -1 : 1;\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayLikeObservable<T> extends Observable<T> {\n\n  static create<T>(arrayLike: ArrayLike<T>, scheduler?: IScheduler): Observable<T> {\n    const length = arrayLike.length;\n    if (length === 0) {\n      return new EmptyObservable<T>();\n    } else if (length === 1) {\n      return new ScalarObservable<T>(<any>arrayLike[0], scheduler);\n    } else {\n      return new ArrayLikeObservable(arrayLike, scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n    const { arrayLike, index, length, subscriber } = state;\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    if (index >= length) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(arrayLike[index]);\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  private value: any;\n\n  constructor(private arrayLike: ArrayLike<T>, private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && arrayLike.length === 1) {\n      this._isScalar = true;\n      this.value = arrayLike[0];\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const { arrayLike, scheduler } = this;\n    const length = arrayLike.length;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n        arrayLike, index, length, subscriber\n      });\n    } else {\n      for (let i = 0; i < length && !subscriber.closed; i++) {\n        subscriber.next(arrayLike[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { Operator } from '../Operator';\nimport { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { TeardownLogic } from '../Subscription';\nimport { Action } from '../scheduler/Action';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(scheduler: IScheduler, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: IScheduler, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  static dispatch(this: Action<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: IScheduler,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    this.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","\nimport { mergeAll } from './mergeAll';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nexport function concatAll<T>(): MonoTypeOperatorFunction<T> {\n  return mergeAll(1);\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>,\n                                  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n                                  concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, I|R> {\n  return function mergeMapOperatorFunction(source: Observable<T>) {\n    if (typeof resultSelector === 'number') {\n      concurrent = <number>resultSelector;\n      resultSelector = null;\n    }\n    return source.lift(new MergeMapOperator(project, <any>resultSelector, concurrent));\n  };\n}\n\nexport class MergeMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<I>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.resultSelector, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<I>, value: T, index: number): void {\n    this.add(subscribeToResult<T, I>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _notifyResultSelector(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","\nimport { Observable } from '../../Observable';\nimport { switchMapTo } from '../../operator/switchMapTo';\n\nObservable.prototype.switchMapTo = switchMapTo;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    switchMapTo: typeof switchMapTo;\n  }\n}","import { Observable, ObservableInput } from '../Observable';\nimport { switchMapTo as higherOrder } from '../operators/switchMapTo';\n\n/* tslint:disable:max-line-length */\nexport function switchMapTo<T, R>(this: Observable<T>, observable: ObservableInput<R>): Observable<R>;\nexport function switchMapTo<T, I, R>(this: Observable<T>, observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nexport function switchMapTo<T, I, R>(this: Observable<T>, innerObservable: Observable<I>,\n                                     resultSelector?: (outerValue: T,\n                                                       innerValue: I,\n                                                       outerIndex: number,\n                                                       innerIndex: number) => R): Observable<I | R> {\n  return higherOrder(innerObservable, resultSelector)(this);\n}\n","import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function switchMapTo<T, R>(observable: ObservableInput<R>): OperatorFunction<T, R>;\nexport function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nexport function switchMapTo<T, I, R>(innerObservable: Observable<I>,\n                                     resultSelector?: (outerValue: T,\n                                                       innerValue: I,\n                                                       outerIndex: number,\n                                                       innerIndex: number) => R): OperatorFunction<T, I | R> {\n  return (source: Observable<T>) => source.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n}\n\nclass SwitchMapToOperator<T, I, R> implements Operator<T, I> {\n  constructor(private observable: Observable<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<I>, source: any): any {\n    return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapToSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<I>,\n              private inner: Observable<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: any) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, this.inner, value, this.index++));\n  }\n\n  protected _complete() {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private tryResultSelector(outerValue: T, innerValue: I,\n                            outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    let result: R;\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  }\n}\n","\nimport { Observable } from '../../Observable';\nimport { delay } from '../../operator/delay';\n\nObservable.prototype.delay = delay;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    delay: typeof delay;\n  }\n}","import { async } from '../scheduler/async';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { delay as higherOrder } from '../operators/delay';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(this: Observable<T>, delay: number|Date,\n                         scheduler: IScheduler = async): Observable<T> {\n  return higherOrder<T>(delay, scheduler)(this);\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Action } from '../scheduler/Action';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { PartialObserver } from '../Observer';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: IScheduler;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: Action<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: IScheduler) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: IScheduler): void {\n    this.active = true;\n    this.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n","export function isDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(+value);\n}\n","\nimport { Observable } from '../../Observable';\nimport { merge } from '../../operator/merge';\n\nObservable.prototype.merge = merge;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    merge: typeof merge;\n  }\n}","import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { merge as higherOrder } from '../operators/merge';\n\nexport { merge as mergeStatic } from '../observable/merge';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(this: Observable<T>, scheduler?: IScheduler): Observable<T>;\nexport function merge<T>(this: Observable<T>, concurrent?: number, scheduler?: IScheduler): Observable<T>;\nexport function merge<T, T2>(this: Observable<T>, v2: ObservableInput<T2>, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2>(this: Observable<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2>;\nexport function merge<T, T2, T3>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(this: Observable<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(this: Observable<T>, ...observables: Array<ObservableInput<T> | IScheduler | number>): Observable<T>;\nexport function merge<T, R>(this: Observable<T>, ...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nexport function merge<T, R>(this: Observable<T>, ...observables: Array<ObservableInput<any> | IScheduler | number>): Observable<R> {\n  return higherOrder(...observables)(this) as Observable<R>;\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\nimport { merge as mergeStatic } from '../observable/merge';\n\nexport { merge as mergeStatic } from '../observable/merge';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function merge<T>(concurrent?: number, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: IScheduler): OperatorFunction<T, T | T2>;\nexport function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2>;\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3>;\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: IScheduler): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: Array<ObservableInput<T> | IScheduler | number>): MonoTypeOperatorFunction<T>;\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | IScheduler | number>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(mergeStatic(source, ...observables));\n}\n","\nimport { Observable } from '../../Observable';\nimport { filter } from '../../operator/filter';\n\nObservable.prototype.filter = filter;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    filter: typeof filter;\n  }\n}","\nimport { Observable } from '../Observable';\nimport { filter as higherOrderFilter } from '../operators/filter';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(this: Observable<T>,\n                                       predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): Observable<S>;\nexport function filter<T>(this: Observable<T>,\n                          predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(this: Observable<T>, predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T> {\n  return higherOrderFilter(predicate, thisArg)(this);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}","\nimport { Observable } from '../../Observable';\nimport { switchMap } from '../../operator/switchMap';\n\nObservable.prototype.switchMap = switchMap;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    switchMap: typeof switchMap;\n  }\n}","\nimport { Observable, ObservableInput } from '../Observable';\nimport { switchMap as higherOrderSwitchMap } from '../operators/switchMap';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<R>): Observable<R>;\nexport function switchMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>,\n                                   resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<I | R> {\n  return higherOrderSwitchMap(project, resultSelector)(this);\n}\n","\nimport { Observable } from '../../Observable';\nimport { mapTo } from '../../operator/mapTo';\n\nObservable.prototype.mapTo = mapTo;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    mapTo: typeof mapTo;\n  }\n}","import { Observable } from '../Observable';\nimport { mapTo as higherOrder } from '../operators/mapTo';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(this: Observable<T>, value: R): Observable<R> {\n  return higherOrder(value)(this);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}","\nimport { Observable } from '../../Observable';\nimport { _switch } from '../../operator/switch';\n\nObservable.prototype.switch = _switch;\nObservable.prototype._switch = _switch;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    switch: typeof _switch;\n    _switch: typeof _switch;\n  }\n}","import { Observable } from '../Observable';\nimport { switchAll as higherOrder } from '../operators/switchAll';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src=\"./img/switch.png\" width=\"100%\">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\nexport function _switch<T>(this: Observable<Observable<T>>): Observable<T> {\n  return higherOrder()(this) as Observable<T>;\n}\n","import { OperatorFunction } from '../interfaces';\nimport { Observable } from '../Observable';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\nexport function switchAll<T>(): OperatorFunction<Observable<T>, T> {\n  return switchMap(identity);\n}\n","\nimport { Observable } from '../../Observable';\nimport { map } from '../../operator/map';\n\nObservable.prototype.map = map;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    map: typeof map;\n  }\n}","import { map as higherOrderMap } from '../operators/map';\nimport { Observable } from '../Observable';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(this: Observable<T>, project: (value: T, index: number) => R, thisArg?: any): Observable<R> {\n  return higherOrderMap(project, thisArg)(this);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","\nimport { Observable } from '../../Observable';\nimport { distinctUntilChanged } from '../../operator/distinctUntilChanged';\n\nObservable.prototype.distinctUntilChanged = distinctUntilChanged;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    distinctUntilChanged: typeof distinctUntilChanged;\n  }\n}","\nimport { Observable } from '../Observable';\nimport { distinctUntilChanged as higherOrder } from '../operators/distinctUntilChanged';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilChanged<T>(this: Observable<T>, compare?: (x: T, y: T) => boolean): Observable<T>;\nexport function distinctUntilChanged<T, K>(this: Observable<T>, compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nexport function distinctUntilChanged<T, K>(this: Observable<T>, compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): Observable<T> {\n  return higherOrder(compare, keySelector)(this);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nexport function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));\n}\n\nclass DistinctUntilChangedOperator<T, K> implements Operator<T, T> {\n  constructor(private compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> {\n  private key: K;\n  private hasKey: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n    super(destination);\n    if (typeof compare === 'function') {\n      this.compare = compare;\n    }\n  }\n\n  private compare(x: any, y: any): boolean {\n    return x === y;\n  }\n\n  protected _next(value: T): void {\n\n    const keySelector = this.keySelector;\n    let key: any = value;\n\n    if (keySelector) {\n      key = tryCatch(this.keySelector)(value);\n      if (key === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    }\n\n    let result: any = false;\n\n    if (this.hasKey) {\n      result = tryCatch(this.compare)(this.key, key);\n      if (result === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    } else {\n      this.hasKey = true;\n    }\n\n    if (Boolean(result) === false) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  }\n}\n","import { Observable } from '../../Observable';\nimport { from as staticFrom } from '../../observable/from';\n\nObservable.from = staticFrom;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let from: typeof staticFrom;\n  }\n}","import { Observable } from '../../Observable';\nimport { of as staticOf } from '../../observable/of';\n\nObservable.of = staticOf;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let of: typeof staticOf; //formOf an iceberg!\n  }\n}","import { Observable } from '../../Observable';\nimport { merge as mergeStatic } from '../../observable/merge';\n\nObservable.merge = mergeStatic;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let merge: typeof mergeStatic;\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _templateObject = _taggedTemplateLiteral(['\\n  height: 100%;\\n  background-repeat: no-repeat;\\n  transition: ', ';\\n\\n  opacity: ', ';\\n  filter: ', ';\\n  /* this is needed so Safari keeps sharp edges */\\n  transform: ', ';\\n'], ['\\n  height: 100%;\\n  background-repeat: no-repeat;\\n  transition: ', ';\\n\\n  opacity: ', ';\\n  filter: ', ';\\n  /* this is needed so Safari keeps sharp edges */\\n  transform: ', ';\\n']);\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _omit = require('ramda/src/omit');\n\nvar _omit2 = _interopRequireDefault(_omit);\n\nvar _styledComponents = require('styled-components');\n\nvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nvar omitProps = (0, _omit2.default)(['blur', 'transition', 'isCached', 'isLoaded', 'opacity', 'scale', 'placeholder']);\n\nvar BaseComponent = function BaseComponent(_ref) {\n  var component = _ref.component,\n      children = _ref.children,\n      otherProps = _objectWithoutProperties(_ref, ['component', 'children']);\n\n  return React.createElement(component, omitProps(otherProps), children);\n};\nBaseComponent.displayName = 'BaseComponent';\nBaseComponent.propTypes = {\n  component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired,\n  children: _propTypes2.default.node // Remind: There is not a children for Input tag.\n};\nvar StyledImg = (0, _styledComponents2.default)(BaseComponent)(_templateObject, function (props) {\n  return props.isCached ? 'none' : props.transition;\n}, function (props) {\n  return props.isLoaded ? 1 : props.opacity;\n}, function (props) {\n  return props.isLoaded ? 'none' : 'blur(' + props.blur + 'px)';\n}, function (props) {\n  return props.isLoaded ? 'none' : 'scale(' + props.scale + ')';\n});\n\nvar Img = function Img(_ref2) {\n  var component = _ref2.component,\n      image = _ref2.image,\n      style = _ref2.style,\n      otherProps = _objectWithoutProperties(_ref2, ['component', 'image', 'style']);\n\n  return React.createElement(StyledImg, Object.assign({}, otherProps, {\n    component: component\n  }, component === 'img' ? { src: image } : {}, {\n    style: Object.assign({}, style, component === 'img' ? {} : { backgroundImage: 'url(\"' + image + '\")' })\n  }));\n};\n\nImg.displayName = 'Img';\nImg.propTypes = {\n  // Internal\n  image: _propTypes2.default.string.isRequired,\n  isLoaded: _propTypes2.default.bool.isRequired,\n  isCached: _propTypes2.default.bool.isRequired,\n\n  // props\n  opacity: _propTypes2.default.number.isRequired,\n  blur: _propTypes2.default.number.isRequired,\n  scale: _propTypes2.default.number.isRequired,\n  className: _propTypes2.default.string,\n  transition: _propTypes2.default.string,\n  style: _propTypes2.default.object,\n  component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func])\n};\n\nexports.default = Img;","var _curry2 = /*#__PURE__*/require('./internal/_curry2');\n\n/**\n * Returns a partial copy of an object omitting the keys specified.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig [String] -> {String: *} -> {String: *}\n * @param {Array} names an array of String property names to omit from the new object\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with properties from `names` not on it.\n * @see R.pick\n * @example\n *\n *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n */\n\n\nvar omit = /*#__PURE__*/_curry2(function omit(names, obj) {\n  var result = {};\n  var index = {};\n  var idx = 0;\n  var len = names.length;\n\n  while (idx < len) {\n    index[names[idx]] = 1;\n    idx += 1;\n  }\n\n  for (var prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n});\nmodule.exports = omit;","var _curry1 = /*#__PURE__*/require('./_curry1');\n\nvar _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}\nmodule.exports = _curry2;","var _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\nmodule.exports = _curry1;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* global Image */\n/* eslint consistent-return: 0 */\nvar isCached = function isCached(test) {\n  return test.complete || test.width + test.height > 0;\n};\n\nvar loadImage = function loadImage(src) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n    image.src = src;\n    // Remind: Check if cached\n    if (isCached(image)) return resolve({ src: src, isCached: true });\n\n    image.onload = function () {\n      return resolve({ src: src, isCached: false });\n    };\n    image.onerror = function (err) {\n      return reject(err);\n    };\n  });\n};\n\nexports.default = loadImage;","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport invariant from 'invariant';\nimport json2mq from 'json2mq';\n\nvar MediaQueryListener =\n/*#__PURE__*/\nfunction () {\n  function MediaQueryListener(targetWindow, query, listener) {\n    var _this = this;\n\n    this.nativeMediaQueryList = targetWindow.matchMedia(query);\n    this.active = true; // Safari doesn't clear up listener with removeListener\n    // when the listener is already waiting in the event queue.\n    // Having an active flag to make sure the listener is not called\n    // after we removeListener.\n\n    this.cancellableListener = function () {\n      _this.matches = _this.nativeMediaQueryList.matches;\n\n      if (_this.active) {\n        listener.apply(void 0, arguments);\n      }\n    };\n\n    this.nativeMediaQueryList.addListener(this.cancellableListener);\n    this.matches = this.nativeMediaQueryList.matches;\n  }\n\n  var _proto = MediaQueryListener.prototype;\n\n  _proto.cancel = function cancel() {\n    this.active = false;\n    this.nativeMediaQueryList.removeListener(this.cancellableListener);\n  };\n\n  return MediaQueryListener;\n}();\n\nvar queryType = PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.arrayOf(PropTypes.object.isRequired)]);\n/**\n * Conditionally renders based on whether or not a media query matches.\n */\n\nvar Media =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Media, _React$Component);\n\n  function Media(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"queries\", []);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getMatches\", function () {\n      var result = _this.queries.reduce(function (acc, _ref) {\n        var _extends2;\n\n        var name = _ref.name,\n            mqListener = _ref.mqListener;\n        return _extends({}, acc, (_extends2 = {}, _extends2[name] = mqListener.matches, _extends2));\n      }, {}); // return result;\n\n\n      return unwrapSingleQuery(result);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updateMatches\", function () {\n      var newMatches = _this.getMatches();\n\n      _this.setState(function () {\n        return {\n          matches: newMatches\n        };\n      }, _this.onChange);\n    });\n\n    !(!(!props.query && !props.queries) || props.query && props.queries) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '<Media> must be supplied with either \"query\" or \"queries\"') : invariant(false) : void 0;\n    !(props.defaultMatches === undefined || !props.query || typeof props.defaultMatches === \"boolean\") ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Media> when query is set, defaultMatches must be a boolean, received \" + typeof props.defaultMatches) : invariant(false) : void 0;\n    !(props.defaultMatches === undefined || !props.queries || typeof props.defaultMatches === \"object\") ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Media> when queries is set, defaultMatches must be a object of booleans, received \" + typeof props.defaultMatches) : invariant(false) : void 0;\n\n    if (typeof window !== \"object\") {\n      // In case we're rendering on the server, apply the default matches\n      var matches;\n\n      if (props.defaultMatches !== undefined) {\n        matches = props.defaultMatches;\n      } else if (props.query) {\n        matches = true;\n      }\n      /* if (props.queries) */\n      else {\n          matches = Object.keys(_this.props.queries).reduce(function (acc, key) {\n            var _extends3;\n\n            return _extends({}, acc, (_extends3 = {}, _extends3[key] = true, _extends3));\n          }, {});\n        }\n\n      _this.state = {\n        matches: matches\n      };\n      return _assertThisInitialized(_this);\n    }\n\n    _this.initialize(); // Instead of calling this.updateMatches, we manually set the initial state to prevent\n    // calling setState, which could trigger an unnecessary second render\n\n\n    _this.state = {\n      matches: _this.props.defaultMatches !== undefined ? _this.props.defaultMatches : _this.getMatches()\n    };\n\n    _this.onChange();\n\n    return _this;\n  }\n\n  var _proto = Media.prototype;\n\n  _proto.initialize = function initialize() {\n    var _this2 = this;\n\n    var targetWindow = this.props.targetWindow || window;\n    !(typeof targetWindow.matchMedia === \"function\") ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Media targetWindow> does not support `matchMedia`.\") : invariant(false) : void 0;\n    var queries = this.props.queries || wrapInQueryObject(this.props.query);\n    this.queries = Object.keys(queries).map(function (name) {\n      var query = queries[name];\n      var qs = typeof query !== \"string\" ? json2mq(query) : query;\n      var mqListener = new MediaQueryListener(targetWindow, qs, _this2.updateMatches);\n      return {\n        name: name,\n        mqListener: mqListener\n      };\n    });\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.initialize(); // If props.defaultMatches has been set, ensure we trigger a two-pass render.\n    // This is useful for SSR with mismatching defaultMatches vs actual matches from window.matchMedia\n    // Details: https://github.com/ReactTraining/react-media/issues/81\n\n    if (this.props.defaultMatches !== undefined) {\n      this.updateMatches();\n    }\n  };\n\n  _proto.onChange = function onChange() {\n    var onChange = this.props.onChange;\n\n    if (onChange) {\n      onChange(this.state.matches);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.queries.forEach(function (_ref2) {\n      var mqListener = _ref2.mqListener;\n      return mqListener.cancel();\n    });\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        render = _this$props.render;\n    var matches = this.state.matches;\n    var isAnyMatches = typeof matches === \"object\" ? Object.keys(matches).some(function (key) {\n      return matches[key];\n    }) : matches;\n    return render ? isAnyMatches ? render(matches) : null : children ? typeof children === \"function\" ? children(matches) : !Array.isArray(children) || children.length // Preact defaults to empty children array\n    ? isAnyMatches ? // We have to check whether child is a composite component or not to decide should we\n    // provide `matches` as a prop or not\n    React.Children.only(children) && typeof React.Children.only(children).type === \"string\" ? React.Children.only(children) : React.cloneElement(React.Children.only(children), {\n      matches: matches\n    }) : null : null : null;\n  };\n\n  return Media;\n}(React.Component);\n/**\n * Wraps a single query in an object. This is used to provide backward compatibility with\n * the old `query` prop (as opposed to `queries`). If only a single query is passed, the object\n * will be unpacked down the line, but this allows our internals to assume an object of queries\n * at all times.\n */\n\n\n_defineProperty(Media, \"propTypes\", {\n  defaultMatches: PropTypes.oneOfType([PropTypes.bool, PropTypes.objectOf(PropTypes.bool)]),\n  query: queryType,\n  queries: PropTypes.objectOf(queryType),\n  render: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  targetWindow: PropTypes.object,\n  onChange: PropTypes.func\n});\n\nfunction wrapInQueryObject(query) {\n  return {\n    __DEFAULT__: query\n  };\n}\n/**\n * Unwraps an object of queries, if it was originally passed as a single query.\n */\n\n\nfunction unwrapSingleQuery(queryObject) {\n  var queryNames = Object.keys(queryObject);\n\n  if (queryNames.length === 1 && queryNames[0] === \"__DEFAULT__\") {\n    return queryObject.__DEFAULT__;\n  }\n\n  return queryObject;\n}\n\nexport default Media;\n","export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}"],"sourceRoot":""}